package network;

import gamelogic.Card;
import gamelogic.Decision;
import gamelogic.Statistics;
import gui.GameSettings;

import java.util.*;
import java.util.stream.Collectors;
import network.Server.PokerProtocolException;

/**
 * Various utility methods for converting between objects and upi-compatible strings representations
 */
public class UpiUtils {

    /**
     * Converts a list of cards into a upi-compatible string
     */
    public static String cardsToString(Card... cards) {
        return Arrays.stream(cards)
                .map(card -> card.suit.name().toLowerCase() + card.rank + " ")
                .reduce("", String::concat);
    }

    /**
     * Converts a map into a upi-compatible string
     */
    public static <K, V> String mapToString(Map<K, V> map) {
        return map.keySet().stream()
                .map(key -> key.toString() + " " + map.get(key).toString() + " ")
                .reduce("", String::concat).trim();
    }

    /**
     *  Turn string into a Map<Integer, Integer>
     * @param mapString String generated by the mapToString()-method
     * @throws PokerProtocolException if parsing error
     */
    private static Map<Integer, Integer> stringToIntIntMap(String mapString) throws PokerProtocolException {
        Map<Integer, Integer> map = new HashMap<>();
        Optional<String []> tokens = tokenize(mapString);
        if (!tokens.isPresent())
            throw new PokerProtocolException("Could not parse mapString " + mapString + " to <Integer, Integer> map");

        for (int i = 0; i < tokens.get().length; i += 2)
            map.put(parseIntToken(tokens.get()[i]), parseIntToken(tokens.get()[i+1]));

        return map;
    }

    /**
     *  Turn a string into a Map<Integer, String>
     * @param mapString String generated by the mapToString()-method
     */
    private static Map<Integer, String> stringToIntStringMap(String mapString) throws PokerProtocolException {
        Map<Integer, String> map = new HashMap<>();
        Optional<String []> tokens = tokenize(mapString);

        if (!tokens.isPresent())
            throw new PokerProtocolException("Could not parse mapString " + mapString + " to <Integer, String> map");

        for (int i = 0; i < tokens.get().length; i += 2)
            map.put(parseIntToken(tokens.get()[i]), tokens.get()[i+1]);

        return map;
    }

    /**
     * Convert settings of this table to a string matching the Lobby Protocol
     * @return <<setting1, value1> <setting2, value2> ... >
     */
    public static String settingsToString(GameSettings settings) {
        return String.format("maxNumberOfPlayers %d startStack %d smallBlind %d bigBlind %d levelDuration %d",
                settings.getMaxNumberOfPlayers(), settings.getStartStack(), settings.getSmallBlind(), settings.getBigBlind(),
                settings.getLevelDuration()).trim();
    }

    /**
     * Parses a upi input line into its tokens, as specified in the protocol
     * @param input A single line of input
     * @return None if the string contained newlines or unclosed quotes, the tokens otherwise
     */
    public static Optional<String[]> tokenize(String input) {
        if (input == null || input.isEmpty()) {
            return Optional.of(new String[0]);
        }
        List<String> tokens = new ArrayList<>();

        int tokenStartIndex = 0;
        boolean parsingQuote = false;
        int i = 0;
        while (i < input.length()) {
            for (i = tokenStartIndex; i < input.length(); i++) {
                if (input.charAt(i) == '\n') {
                    return Optional.empty();
                }
                if (input.charAt(i) == '\"') {
                    tokenStartIndex = i + 1;
                    parsingQuote = true;
                    break;
                }
                else if (!Character.isWhitespace(input.charAt(i))) {
                    tokenStartIndex = i;
                    parsingQuote = false;
                    break;
                }
            }

            for (i = tokenStartIndex; i < input.length(); i++) {
                if (input.charAt(i) == '\n') {
                    return Optional.empty();
                }
                if (parsingQuote) {
                    if (input.charAt(i) == '\"') {
                        tokens.add(input.substring(tokenStartIndex, i));
                        parsingQuote = false;
                        tokenStartIndex = i + 1;
                        break;
                    }
                } else {
                    if (Character.isWhitespace(input.charAt(i))) {
                        tokens.add(input.substring(tokenStartIndex, i));
                        tokenStartIndex = i + 1;
                        break;
                    }
                }
            }
        }
        if (parsingQuote) {
            return Optional.empty();
        }
        else if (tokenStartIndex < input.length() && !Character.isWhitespace(input.charAt(tokenStartIndex)) && input.charAt(tokenStartIndex) != '\"') {
            tokens.add(input.substring(tokenStartIndex));
        }
        tokens = tokens.stream().map(String::trim)
                .filter(s -> s.length() > 0)
                .filter(s -> s.length() > 1 || Character.isLetterOrDigit(s.charAt(0)))
                .collect(Collectors.toList());
        return Optional.of(tokens.toArray(new String[tokens.size()]));

    }

    /**
     *  Turn a decision into a string that conforms with the network protocol (upi)
     *  Adds a 'decision' token in front of the decision
     */
    public static String decisionToString(Decision decision) {
        if (decision.move == Decision.Move.RAISE || decision.move == Decision.Move.BET) {
            return "decision " + decision.move.toString().toLowerCase() + decision.getSize();
        }
        else if (decision.move == Decision.Move.BIG_BLIND) {
            return "decision bigBlind";
        }
        else if (decision.move == Decision.Move.SMALL_BLIND) {
            return "decision smallBlind";
        }
        else {
            return "decision " + decision.move.toString().toLowerCase();
        }
    }

    public static Optional<Decision> parseDecision(String string) {
        if (string == null) {
            return Optional.empty();
        }
        int firstDigitIndex = 0;
        for (int i = 0; i < string.length(); i++) {
            if (Character.isDigit(string.charAt(i))) {
                firstDigitIndex = i;
                break;
            }
        }
        if (firstDigitIndex == 0) {
            try {
                return Optional.of(new Decision(parseMove(string).get()));
            }
            catch (NoSuchElementException | IllegalArgumentException e) {
                return Optional.empty();
            }
        }
        else {
            try {
                return Optional.of(new Decision(parseMove(string.substring(0, firstDigitIndex)).get(), Long.parseLong(string.substring(firstDigitIndex))));
            }
            catch (NoSuchElementException | IllegalArgumentException e) {
                return Optional.empty();
            }
        }
    }

    /**
     * @return A upi compatible String containing the move
     */
    public static Optional<Decision.Move> parseMove(String string) {
        switch (string) {
            case "smallBlind":
                return Optional.of(Decision.Move.SMALL_BLIND);
            case "bigBlind":
                return Optional.of(Decision.Move.BIG_BLIND);
            case "allin":
                return Optional.of(Decision.Move.ALL_IN);
            default:
                try {
                    return Optional.of(Decision.Move.valueOf(string.toUpperCase()));
                }
                catch (IllegalArgumentException e) {
                    return Optional.empty();
                }
        }
    }

    /**
     * Like Integer.parseInt,except that it throws a checked exception if it fails
     * @param input String token
     * @return int token
     * @throws PokerProtocolException
     */
    public static int parseIntToken(String input) throws PokerProtocolException {
        try {
            return Integer.parseInt(input);
        }
        catch (NumberFormatException e) {
            throw new PokerProtocolException("Error parsing " + input + " to int");
        }
    }

    /**
     * Like Long.parseLong,except that it throws a checked exception if it fails
     * @param input String token
     * @return long token
     * @throws PokerProtocolException
     */
    public static long parseLongToken(String input) throws PokerProtocolException {
        try {
            return Long.parseLong(input);
        }
        catch (NumberFormatException e) {
            throw new PokerProtocolException("Error parsing " + input + " to long");
        }
    }

    /**
     * Parse a string to a card
     */
    public static Card parseCard(String input) {
        if (input.startsWith("spades")) {
            int rank = Integer.parseInt(input.substring("spades".length()));
            return Card.of(rank, Card.Suit.SPADES).get();
        }
        else if (input.startsWith("hearts")) {
            int rank = Integer.parseInt(input.substring("hearts".length()));
            return Card.of(rank, Card.Suit.HEARTS).get();
        }
        else if (input.startsWith("diamonds")) {
            int rank = Integer.parseInt(input.substring("diamonds".length()));
            return Card.of(rank, Card.Suit.DIAMONDS).get();
        }
        else if (input.startsWith("clubs")) {
            int rank = Integer.parseInt(input.substring("clubs".length()));
            return Card.of(rank, Card.Suit.CLUBS).get();
        }
        throw new IllegalArgumentException("Couldn't parse card " + input);
    }

    /**
     *  Turns a upi string into an optional statistics object
     *  @return an optional statistics object (empty if parsing failed)
     *  @throws PokerProtocolException
     */
    public static Optional<Statistics> upiStringToStatistics(String input) throws PokerProtocolException {
        Optional<String []> tokens = UpiUtils.tokenize(input);
        if (!tokens.isPresent())
            return Optional.empty();

        try {
            int pID = parseIntToken(tokens.get()[2]);
            String rankingTableString = tokens.get()[4];
            String namesString = tokens.get()[6];
            int handsWon = parseIntToken(tokens.get()[8]);
            int handsPlayed = parseIntToken(tokens.get()[10]);
            int foldsPreFlop = parseIntToken(tokens.get()[12]);
            int aggressiveMoves = parseIntToken(tokens.get()[14]);
            int passiveMoves = parseIntToken(tokens.get()[16]);
            String bestHand = tokens.get()[18];

            return Optional.of(new Statistics(pID, stringToIntIntMap(rankingTableString), stringToIntStringMap(namesString), handsWon, handsPlayed, foldsPreFlop, aggressiveMoves, passiveMoves, bestHand));
        } catch (PokerProtocolException ppe) {
            ppe.printStackTrace();
            return Optional.empty();
        }
    }
}
